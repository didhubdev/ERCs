---
eip: 7536
title: Hierarchical Conditional NFTs
description: A specification on the conditional generation of NFT descendents with different attributes.
author: Henry Yeung (@henrywfyeung) <henry@didhub.com>, Alex Yang <alex@didhub.com>
discussions-to: https://ethereum-magicians.org/t/eip-idea-multi-edition-nft-distribution/16092
status: Draft
type: Standards Track
category: ERC
created: 2023-10-15
requires: 165, 721
---

## Abstract

This standard extends [ERC-721](./eip-721.md) to enable conditional minting of various editions of child tokens with specific privileges attached. An edition is defined as a version of a child token that encapsulates a descriptor to the parent, the address to a validator that validates the fulfilment of predefined rules before minting the child token, and a set of attributes that will be processed by the child token. Each parent token can create multiple editions, each with a different set of rules to obtain the child tokens, and with different set of attributes attached. Upon fulfilling the corresponding rules from a specific edition, one can obtain the child token and will be able to use the token within the boundaries set by the parent token holder.

## Motivation

Most community-based relationships can be regarded as a social structure with a community owner, and multiple tiers of community members. Each tier has its own cost and benefit of joining. This can apply to the Profile-Follower relationship, Creation-Collection relationship, Producer-Subscriber relationship, Dao-Member relationship, etc.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

![Parent Child and Edition Relationship Diagram](../assets/eip-7536/assets/edition.png)

### The Distributor Interface

```solidity
pragma solidity >=0.8.0 <0.9.0;


/**
 * @notice The Distributor interface dictates how the holder of any ERC721 compliant tokens, both external and internal to the contract, to create editions that collectors can conditionally mint child tokens from. External token holders can use the registerOrigin function to register the ERC721 compliant token with the contract. This function will generate a unique identifier for the external token, which can be used as a proxy to invoke contract functions under the same interface as internal tokens. Parent token holders can use the setEdition to specify the condition for minting an edition of the parent token. An edition is defined by a tokenId of the parent token, the attribute of the child tokens, the address of the validator contract that specifies the rules to obtain the child token, and the data to initialize these rules. A Collector can mint a child token of an Edition given that the rules specified by the Validator are fulfilled. Parent tokens holder can set multiple different editions, each with a different set of rules, and a different set of attributes that the token holder will be empowered with after the minting of the token.
 */
interface IDistributor {

    /**
     * @dev Emitted when an origin is set
     */
    event RegisterOrigin(address tokenContract, uint256 tokenId, uint256 uniqueIdentifier);
    
    /**
     * @dev Emitted when an edition is created
     * 
     * @param editionHash The hash of the edition configuration
     * @param tokenId The token id of the NFT descriptor
     * @param validator The address of the validator contract
     * @param attribute The functions that will be permitted.
     */
    event SetEdition(bytes32 editionHash, uint256 tokenId, address validator, uint96 attribute);
    
    /**
     * @dev Emitted when an edition is paused
     * 
     * @param editionHash The hash of the edition configuration
     * @param isPaused The state of the edition
     */
    event PauseEdition(bytes32 editionHash, bool isPaused);

    /**
     * @dev Generates a unique identifier with the token for edition, the entry point
     */
    function registerOrigin (address tokenContract, uint256 tokenId, bytes memory data) external;

    /**
     * @dev The parent token holder can set an edition that enables others
     * to mint child tokens given that they fulfill the given rules
     *
     * @param tokenId the token id of the NFT descriptor
     * @param validator the address of the validator contract
     * @param attribute the attribute of the child token.
     * @param ruleInitData the data to be input into the validator contract for seting up the rules
     * 
     * @return editionHash Returns the hash of the edition configuration 
     */
    function setEdition(
        uint256 tokenId,
        address validator,
        uint96  attribute,
        bytes calldata ruleInitData
    ) external returns (bytes32 editionHash);
    
    /**
     * @dev The parent token holder can pause the edition
     *
     * @param editionHash the hash of the edition
     * @param isPaused the state of the edition
     */ 
    function pauseEdition(
        bytes32 editionHash,
        bool isPaused
    ) external;

}
```

### The Validator Interface

```solidity
pragma solidity >=0.8.0 <0.9.0;

/**
 * @notice This is the validator interface. It specifies the rules that need to be fulfilled and enforces the fulfillment of these rules. The parent token holder is required to first register these rules onto a particular edition, identified by the hash of the edition configuration (editionHash). When a collector wants to invoke a certain action associated with the editionHash, i.e., mint a token from the edition, the collector will need to pass the validation by successfully calling the validate function. In the validation process, the collector will need to supply the basic information including the initiator (the address of the collector), editionHash, and some optional fullfilmentData. The validate function will revert upon error, and will return nothing if the validation is successful.
 */
interface IValidator {

    /**
     * @dev Sets up the validator rules by the edition hash and the data for initialization. This function will
     * decode the data back to the required parameters and sets up the rules that decides who can or cannot
     * invoke a particular action.
     *
     * @param editionHash The hash of the edition configuration
     * @param ruleInitData The data bytes for initializing the validation rules. Parameters are encoded into bytes
     */
    function setRules(
        bytes32 editionHash,
        bytes calldata ruleInitData
    ) external;

    /**
     * @dev Supply the data that will be used to validate the fulfilment of the rules setup by the parent token holder.
     *
     * @param initiator the party who initiate vadiation
     * @param editionHash the hash of the edition configuration
     * @param actionType the type of action to validation
     * @param fullfilmentData the addtion data that is required for passing the validator rules
     */
    function validate(
        address initiator,
        bytes32 editionHash,
        uint256 actionType,
        bytes calldata fullfilmentData
    ) external payable;
    
}
```

## Rationale

### Usage
The Distributor Interface enables any ERC-721 token to create multiple editions, each with distinct rules validated by the Validator Interface before minting a child token, and a set of actions available post-minting. This is advantageous for community building, with diverse use cases like:
- **Copy Issuance of Unique Artwork/Content:** Artists can issue multiple copies of their unique artworks with different functions and rules, providing flexibility to both creators and collectors.
- **Partial Copyright Transfer:** Creators can conditionally delegate varying levels of copyrights, allowing for derivative work production without selling the original copy.
Consider using this standard for:
- Selling copies of unique Art/Music NFTs while retaining control over the copies.
- Selling time-limited copies of artwork with attached copyright statements for derivative work production.
- Issuing non-transferable Graduation Certificates as NFTs, where the university retains the revocation right.
- **Community Management with a Single Parent Token or a Selected Edition of Child Tokens** The default setup enables a single parent token to set editions and the corresponding validation rules. A potentially advanced setup could delegate the management role to a particular edition of child tokens.

### The Main Contract that Implements the Distributor Interface for Edition Creation

The main contract must implement both the ERC-721 and the Distributor Interface. The Distributor Interface provides functions to to setup editions and the corresponding validation rules. Optionally, the main contract may implement additional functions that are guarded by the the actions parameter, denoted as action bits (uint96) in the editions. Such a design removes the dependency of the edition based permission control on the implementation of contract functions. However, the design only enables invocation of functions using actions parameter, but it does not specify the party. It is up to the developer to set up additional ownership checks, i.e. the action bits ensure the invocation of the "revoke token" function on the child token is permitted, but it requires additional ownership check in the contract to make sure this is a parent token only function.

### Flexible Implementation of Actions

The actions that can be performed are defined in the edition as a uint96 integer. Each bit in the integer determines whether a particular function can be invoked in the contract, with a maximum of 96 functions. The actions can be implemented flexibly depending on the specific use cases. For instance, if the parent token wants to have full control over the child token, the edition, together with the function setup, can permit the parent token holder to invocate a function that transfers the child token to the parent token holder.

Actions may give the child tokens the following characteristics:

- non-transferable: An SBT that is bound to a user's wallet address
- revokable: The creator has control over the minted copies. This is suitable for NFTs that encapsulate follower relationships, or funtions as some kind of revokable permits
- extendable: NFT is valid over a duration and requires extension. This is suitable for recurring memberships.
- updateable: Allows the child token holder to update the tokenUri when the parent token is updated
- vote: Child token holder can vote if the vote action bit is set
- external contract actions: An externally deployed contract that implements functions with permissions controlled by the action bits in the contract with the Distributor interface

### External or Internal Implementation of the Validator Interface 

The Validator Interface can be implemented externally as an independent contract, or internally as part of the contract that issues the child token. The former approach is more upgrade-friendly, i.e., validation contracts can be easily swapped to a higher version, while still maintaining compatibility to past versions. More it permits multiple different validators to coexist at the same time. The latter one is less composable, but more secure, as it does not depend on third-party code. This is prefered if the validated rules are unlikely to change in the future.

### Flexible Implementation of Validation Rules

The Validator Contract can be customized to enforce rules, including:

- Fee: Requires payment to mint
- Free: No Condition to mint
- NFT Holder: Process a particular NFT to mint
- [ERC-20](./eip-20.md) Holder: Process a certain amount of ERC-20 tokens to mint
- Whitelist: In the whitelist to mint.
- Limited Issuance: Fixed Maximum number of issued copies.
- Limited Time: Enables minting within a particular time frame.


## Backwards Compatibility

This standard is compatible with [ERC-721](./eip-721.md).

## Reference Implementation

The reference implementation is given in  `../assets/erc-7536/`.

## Security Considerations

The current design permits the use of an external validator contract which may not implement secure logic and may potentially be malicious. The distributor contract could whitelist a subset of trusted validators. Moreover, an ERC-721 contract may at the same time implement both the distributor and the validator interfaces to remove the dependency on external contracts.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
