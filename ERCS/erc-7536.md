---
eip: 7536
title: Hierarchical Conditional NFTs
description: Conditional generation of NFT descendants with different attributes.
author: Henry Yeung (@henrywfyeung) <henry@didhub.com>, Alex Yang <alex@didhub.com>
discussions-to: https://ethereum-magicians.org/t/eip-idea-multi-edition-nft-distribution/16092
status: Draft
type: Standards Track
category: ERC
created: 2023-10-15
requires: 165, 721
---

## Abstract

This standard extends [ERC-721](./eip-721.md) to enable conditional minting of various editions of child tokens, specified by external or internal parent tokens. An edition is defined as a version of a child token that encapsulates a descriptor to the parent, an address to a validator contract that validates the fulfillment of predefined rules before minting the child token, and a set of attributes that will be processed by the child token. Each parent token can create multiple editions, each with a different set of rules to obtain the child tokens, and with a different set of attributes attached. Upon fulfilling the rules of the validator contract specified in the edition, one can obtain the child token and will be able to use the token within the boundaries set by the parent token holder. The child tokens may continue to set the conditions for generating their own offspring, forming an hierarchy of descendant tokens.

## Motivation

Most community-based relationships can be regarded as a social structure with a community owner, and a hierarchy of community members. Each tier has its own cost and benefit of joining. This can apply to the Profile-Follower relationship, Creation-Collection relationship, Producer-Subscriber relationship, Dao-Member relationship, etc.

The Distributor Interface enables any ERC-721 token to create multiple editions, each with distinct rules validated by the Validator Interface before minting a child token, and a set of attributes available post-minting. This is advantageous for community building, with diverse use cases like:
- **Copy Issuance of Unique Artwork/Content:** Artists can issue multiple copies of their unique artworks with different functions and rules, providing flexibility to both creators and collectors.
- **Partial Copyright Transfer:** Creators can conditionally delegate varying levels of copyrights, allowing for derivative work production without selling the original copy.
Consider using this standard for:
- Selling copies of unique Art/Music NFTs while retaining control over the copies.
- Selling time-limited copies of artwork with attached copyright statements for derivative work production.
- Issuing non-transferable Graduation Certificates as NFTs, where the university retains the revocation right.
- **Community Management with a Single Parent Token or a Selected Edition of Child Tokens** The default setup enables a single parent token to set editions and the corresponding validation rules. A potentially advanced setup could delegate the management role to a particular edition of child tokens.


## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

![Parent Child and Edition Relationship Diagram](../assets/erc-7536/assets/7536.svg)

### The Distributor Interface

```solidity
pragma solidity >=0.8.0 <0.9.0;


/**
 * @notice The Distributor interface dictates how the holder of any ERC721 compliant tokens, both external and internal to the contract, to create editions that collectors can conditionally mint child tokens from. Parent token holders can use the setEdition to specify the condition for minting an edition of the parent token. An edition is defined by a tokenId of the parent token, the attribute of the child tokens, the address of the validator contract that specifies the rules to obtain the child token, and the data to initialize these rules. A Collector can mint a child token of an Edition given that the rules specified by the Validator are fulfilled. Parent tokens holder can set multiple different editions, each with a different set of rules, and a different set of attributes that the token holder will be empowered with after the minting of the token.
 */
interface IDistributor {
    
    /**
     * @dev Emitted when an edition is created
     * 
     * @param editionHash The hash of the edition configuration
     * @param tokenId The token id of the NFT descriptor
     * @param validator The address of the validator contract
     * @param attribute The functions that will be permitted.
     */
    event SetEdition(bytes32 editionHash, uint256 tokenId, address validator, uint96 attribute);
    
    /**
     * @dev Emitted when an edition is paused
     * 
     * @param editionHash The hash of the edition configuration
     * @param isPaused The state of the edition
     */
    event PauseEdition(bytes32 editionHash, bool isPaused);

    /**
     * @dev The parent token holder can set an edition that enables others
     * to mint child tokens given that they fulfill the given rules
     *
     * @param tokenId the token id of the NFT descriptor
     * @param validator the address of the validator contract
     * @param attribute the attribute of the child token.
     * @param ruleInitData the data to be input into the validator contract for seting up the rules
     * 
     * @return editionHash Returns the hash of the edition configuration 
     */
    function setEdition(
        uint256 tokenId,
        address validator,
        uint96  attribute,
        bytes calldata ruleInitData
    ) external returns (bytes32 editionHash);
    
    /**
     * @dev The parent token holder can pause the edition
     *
     * @param editionHash the hash of the edition
     * @param isPaused the state of the edition
     */ 
    function pauseEdition(
        bytes32 editionHash,
        bool isPaused
    ) external;

}
```

### The Validator Interface

```solidity
pragma solidity >=0.8.0 <0.9.0;

/**
 * @notice This is the validator interface. It specifies the rules that need to be fulfilled and enforces the fulfillment of these rules. The parent token holder is required to first register these rules onto a particular edition, identified by the hash of the edition configuration (editionHash). When a collector wants to invoke a certain action associated with the editionHash, i.e., mint a token from the edition, the collector will need to pass the validation by successfully calling the validate function. In the validation process, the collector will need to supply the basic information including the initiator (the address of the collector), editionHash, and some optional fullfilmentData. The validate function will revert upon error, and will return nothing if the validation is successful.
 */
interface IValidator {

    /**
     * @dev Sets up the validator rules by the edition hash and the data for initialization. This function will
     * decode the data back to the required parameters and sets up the rules that decides who can or cannot
     * invoke a particular action.
     *
     * @param editionHash The hash of the edition configuration
     * @param ruleInitData The data bytes for initializing the validation rules. Parameters are encoded into bytes
     */
    function setRules(
        bytes32 editionHash,
        bytes calldata ruleInitData
    ) external;

    /**
     * @dev Supply the data that will be used to validate the fulfilment of the rules setup by the parent token holder.
     *
     * @param initiator the party who initiate vadiation
     * @param editionHash the hash of the edition configuration
     * @param actionType the type of action to validation
     * @param fullfilmentData the addtion data that is required for passing the validator rules
     */
    function validate(
        address initiator,
        bytes32 editionHash,
        uint256 actionType,
        bytes calldata fullfilmentData
    ) external payable;
    
}
```

### The Origin Interface (Optional)


```solidity
pragma solidity >=0.8.0 <0.9.0;

/**
 * @notice The Origin interface is an optional interface. External token holders can use the registerOrigin function to register the ERC721 compliant token with the contract. This function will generate a unique identifier for the external token, which can be used as a proxy to invoke contract functions under the same interface as internal tokens. Implementation should take extra care to ensure that the unique identifier is unique across all external and internal tokens.
 */
interface IOrigin {

    /**
     * @dev Emitted when an origin is set
     * 
     * @param tokenContract The address of the external token contract
     * @param tokenId The token id of the external token
     * @param uniqueIdentifier The unique identifier generated for the external token
     */
    event RegisterOrigin(address tokenContract, uint256 tokenId, uint256 uniqueIdentifier);
    
    /**
     * @dev Generates a unique identifier with the token for edition, the entry point
     * 
     * @param tokenContract The address of the external token contract
     * @param tokenId The token id of the external token
     * @param data The data to be input into the contract for setting up the rules
     * 
     * @return uniqueIdentifier Returns the unique identifier generated for the external token
     */
    function registerOrigin (address tokenContract, uint256 tokenId, bytes memory data) external returns (uint256 uniqueIdentifier);

}
```

## Rationale

### The Main Contract that Implements the Distributor Interface for Edition Creation

The main contract must implement both the ERC-721 and the Distributor Interface. The Distributor Interface provides the functions to set up editions and initialize the corresponding validation contract. The main contract is recommended to implement a function that enables the minting of the child token, and this function should be guarded by a validator contract.

### Generation of a Hierarchical NFT Structure

The NFT hierarchy starts with a top-level ERC-721 token that can be an external token, i.e. token from other ERC-721 contracts, or internal tokens, i.e. tokens minted from the contract that implements this standard. The registerOrigin interface permits the registration of external ERC-721 tokens into the system by generating a unique identifier, also known as internal tokenIds, for them. The uniqueness of the identifier should be guaranteed by the implementation, where tokenId clashes between external unique identifiers and internally assigned tokenIds should be avoided. For instance, internal tokenIds can be generated based on the hash of the token contract and a counter on the number of already generated tokens, whereas the external unique identifier can be generated from the hash of the external token contract and the external tokenId. This standard thus enables child tokens to be generated based on an external parent NFT token via the setup of editions. Moreover, the child tokens can again set up new editions that enables the generation of their own descendants, thus forming a hierarchy of NFTs.

### Complicated Validation Logic as a Hook

The validator contract can define complicated validation processes for different types of actions. For instance, it can define conditions such as ERC-20 token payment, NFT procession, and start/end time for token minting action. It can also be used as a hook before or after ERC-721-related actions, such as transfer and approval, or any custom actions.

### Flexible Control Logic Based on Bits Encoded in the Attribute

The main contract may optionally implement additional functions that are guarded by the attribute parameter, a 96-bit data (uint96) in the editions. Each bit in the integer determines whether a particular function can be invoked in the contract, with a maximum of 96 functions. The actions can be implemented flexibly depending on the specific use cases. For instance, we can set a bit to permit the invocation of the "revoke token" function on the child token. Such a function can be guarded by an ownership check on the parent token to ensure that only the parent token holder can revoke the child token. This works best for privileges that can be delegated to the child token owner upon minting, so that no further complicated validation is needed during the function call.

Actions may give the child tokens the following characteristics:

- non-transferable: An SBT that is bound to a user's wallet address
- revokable: The creator has control over the minted copies. This is suitable for NFTs that encapsulate follower relationships, or functions as some kind of revokable permits
- extendable: NFT is valid over a duration and requires an extension. This is suitable for recurring memberships.
- updateable: Allows the child token holder to update the tokenUri when the parent token is updated
- vote: Child token holder can vote if the vote action bit is set
- external contract actions: An externally deployed contract that implements functions with permissions controlled by the action bits in the contract with the Distributor interface

### External or Internal Implementation of the Validator Interface 

The Validator Interface can be implemented externally as an independent contract, or internally as part of the contract that issues the child token. The former approach is more upgrade-friendly, i.e., validation contracts can be easily swapped to a newer version, while still maintaining compatibility with past versions. Furthermore, it permits multiple different validators to coexist at the same time. The latter one is less composable, but more secure, as it does not depend on third-party code. This is preferred if the validated rules are unlikely to change in the future.

### Flexible Implementation of Validation Rules

The Validator Contract can be customized to enforce rules, including:

- Fee: Requires payment to mint
- Free: No Condition to mint
- NFT Holder: Process a particular NFT to mint
- [ERC-20](./eip-20.md) Holder: Process a certain amount of ERC-20 tokens to mint
- Whitelist: In the whitelist to mint.
- Limited Issuance: Fixed Maximum number of issued copies.
- Limited Time: Enables minting within a particular time frame.

## Backwards Compatibility

This standard is fully backward compatible with [ERC-721](./eip-721.md). This standard is also fully backward compatible with the non-optional interfaces of [ERC-6150](./eip-6150.md), and all the optional extension interfaces except the ParentTransferable interface, since the parent-child relationship in this standard, once formed, can no longer be altered. ERC-6150 specifies a standard for the composition of the NFT hierarchy, whereas this standard specifies a standard for the process of creation of an NFT hierarchy.

## Reference Implementation

The reference implementation is given in  `../assets/erc-7536/`.

## Security Considerations

The current design permits the use of an external validator contract which may not implement secure logic and may potentially be malicious. The distributor contract could whitelist a set of trusted validators. Moreover, an ERC-721 contract may at the same time implement both the distributor and the validator interfaces to remove the dependency on external contracts.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
